# 재귀(recusion)
재귀의 정의는 **어떠한 것을 정의할 때 자기 자신을 참조하는 것**이다.<br>
이때, 재귀적으로 정의된 함수를 **재귀함수**라고 한다.


```python
def recursive(number):
    print(number)
    recursive(number + 1)

recursive(1)
```

위 코드를 실행해보면 프로그램이 자동으로 종료된다.
콜스택이 계속 쌓여서 메모리가 부족해졌기 떄문이다.

<img src="../assets/algorithm-recursion.png" style="width: 600px; height: 400px">

위와 같은 에러를 해결하기 위해서,<br>
재귀함수는 **탈출 조건(기저 조건)** 이 반드시 있어야 한다.


```python
def recursive(number):
    if number <= 10:
        print(number)
        recursive(number + 1)

# 또는

def recursive(number):
    if number > 10:
        return
    print(number)
    recursive(number + 1)

recursive(1)
```

---

## 콜스택
**콜스택(Call Stack)** 은 `함수 호출과 관련된 실행 정보(스택 프레임)`가 저장되는 스택 구조의 메모리 영역이다.<br>
함수가 호출되면 새로운 스택 프레임이 생성되어 콜스택에 추가되며, 함수가 종료되면 해당 스택 프레임이 콜스택에서 제거된다.

**스택 프레임(Stack Frame)** 에는 함수의 매개변수, 호출이 끝난 뒤 돌아갈 반환 주소, 함수 내 지역 변수 등 함수 실행에 필요한 정보가 포함된다.

하지만 앞서 본 코드처럼 탈출조건이 없거나 잘못된 재귀함수는 
`스택 오버플로우(stack overflow)`가 발생할 수 있다. 

재귀 함수는 호출할 때마다 콜스택이 쌓이기 때문에 반복문보다 더 많은 메모리 공간을 차지한다.
그럼에도 불구하고 재귀를 사용하는 이유는 반복문으로는 해결하기 복잡한 문제를 쉽게 해결할 수 있기 때문이다.

### 예시: 팩토리얼
```python
def factorial(number):
    if number < 0:
        raise ValueError("0 또는 자연수만 입력 가능합니다.")
    if number == 0:
        return 1
    if number < 3:
        return number
    return number * factorial(number - 1)
```

> [그림으로 쉽게 배우는 자료구조와 알고리즘 (기본편)](https://www.inflearn.com/courses/lecture?courseId=328971&type=LECTURE&unitId=115670&subtitleLanguage=ko&tab=curriculum) Section3 Unit1 시청 후 정리

> 추가 참고 
> [스택 프레임](https://www.tcpschool.com/c/c_memory_stackframe)