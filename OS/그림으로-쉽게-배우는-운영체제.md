> 인프런 [그림으로 쉽게 배우는 운영체제](https://inf.run/amX3v) 강의를 기반으로 학습한 내용을 정리합니다.
>

<!-- TOC -->

- [Section1. 운영체제 들어가기](#section1-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EB%93%A4%EC%96%B4%EA%B0%80%EA%B8%B0)
	- [운영체제 개요](#%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EA%B0%9C%EC%9A%94)
		- [컴퓨터는 운영체제 없이도 동작할 수 있다.](#%EC%BB%B4%ED%93%A8%ED%84%B0%EB%8A%94-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EC%97%86%EC%9D%B4%EB%8F%84-%EB%8F%99%EC%9E%91%ED%95%A0-%EC%88%98-%EC%9E%88%EB%8B%A4)
		- [운영체제가 하는 일](#%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C%EA%B0%80-%ED%95%98%EB%8A%94-%EC%9D%BC)
	- [운영체제의 역사](#%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C%EC%9D%98-%EC%97%AD%EC%82%AC)
		- [1 1940년도: 에니악의 등장](#1-1940%EB%85%84%EB%8F%84-%EC%97%90%EB%8B%88%EC%95%85%EC%9D%98-%EB%93%B1%EC%9E%A5)
		- [2 1950년도 초반: 직접 회로IC의 개발](#2-1950%EB%85%84%EB%8F%84-%EC%B4%88%EB%B0%98-%EC%A7%81%EC%A0%91-%ED%9A%8C%EB%A1%9Cic%EC%9D%98-%EA%B0%9C%EB%B0%9C)
		- [3 1950년도 중후반: 싱글스트림 배치시스템](#3-1950%EB%85%84%EB%8F%84-%EC%A4%91%ED%9B%84%EB%B0%98-%EC%8B%B1%EA%B8%80%EC%8A%A4%ED%8A%B8%EB%A6%BC-%EB%B0%B0%EC%B9%98%EC%8B%9C%EC%8A%A4%ED%85%9C)
		- [4 1960년대: 시분할 시스템](#4-1960%EB%85%84%EB%8C%80-%EC%8B%9C%EB%B6%84%ED%95%A0-%EC%8B%9C%EC%8A%A4%ED%85%9C)
		- [5 1970년대: 개인용 컴퓨터의 시대 시작](#5-1970%EB%85%84%EB%8C%80-%EA%B0%9C%EC%9D%B8%EC%9A%A9-%EC%BB%B4%ED%93%A8%ED%84%B0%EC%9D%98-%EC%8B%9C%EB%8C%80-%EC%8B%9C%EC%9E%91)
	- [운영체제의 구조](#%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C%EC%9D%98-%EA%B5%AC%EC%A1%B0)
	- [컴퓨터 하드웨어와 구조](#%EC%BB%B4%ED%93%A8%ED%84%B0-%ED%95%98%EB%93%9C%EC%9B%A8%EC%96%B4%EC%99%80-%EA%B5%AC%EC%A1%B0)
		- [폰 노이만 구조](#%ED%8F%B0-%EB%85%B8%EC%9D%B4%EB%A7%8C-%EA%B5%AC%EC%A1%B0)
			- [CPU 구조](#cpu-%EA%B5%AC%EC%A1%B0)
			- [메모리 종류](#%EB%A9%94%EB%AA%A8%EB%A6%AC-%EC%A2%85%EB%A5%98)
	- [컴퓨터의 부팅 과정](#%EC%BB%B4%ED%93%A8%ED%84%B0%EC%9D%98-%EB%B6%80%ED%8C%85-%EA%B3%BC%EC%A0%95)
	- [인터럽트Interrupt](#%EC%9D%B8%ED%84%B0%EB%9F%BD%ED%8A%B8interrupt)
		- [인터럽트의 필요성](#%EC%9D%B8%ED%84%B0%EB%9F%BD%ED%8A%B8%EC%9D%98-%ED%95%84%EC%9A%94%EC%84%B1)
		- [실행 과정](#%EC%8B%A4%ED%96%89-%EA%B3%BC%EC%A0%95)
		- [인터럽트 종류](#%EC%9D%B8%ED%84%B0%EB%9F%BD%ED%8A%B8-%EC%A2%85%EB%A5%98)
- [Section2. 프로세스와 스레드](#section2-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%99%80-%EC%8A%A4%EB%A0%88%EB%93%9C)
	- [프로그램과 프로세스](#%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8%EA%B3%BC-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4)
		- [프로그램Program](#%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8program)
		- [프로세스Process](#%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4process)
			- [프로세스 메모리 구조](#%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B5%AC%EC%A1%B0)
		- [C언어 컴파일 과정](#c%EC%96%B8%EC%96%B4-%EC%BB%B4%ED%8C%8C%EC%9D%BC-%EA%B3%BC%EC%A0%95)
	- [멀티 프로그래밍과 멀티 프로세싱](#%EB%A9%80%ED%8B%B0-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%EA%B3%BC-%EB%A9%80%ED%8B%B0-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8B%B1)
	- [PCBProcess Control Back](#pcbprocess-control-back)
		- [PCB 구조](#pcb-%EA%B5%AC%EC%A1%B0)
	- [프로세스 상태](#%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EC%83%81%ED%83%9C)

<!-- /TOC -->


<br>

# Section1. 운영체제 들어가기
## 운영체제 개요
- 개인용 컴퓨터 → Windows / MacOs
- 대형 컴퓨터 / 서버용 → 유닉스 / 리눅스
- 스마트폰 / 태블릿 → 안드로이드 / ios 운영체제
- 내비게이션 / 스마트워치 / 냉장고 / 세탁기 → 임베디드 운영체제

### 컴퓨터는 운영체제 없이도 동작할 수 있다.
다만, 처음 설계한 그대로만 동작할 뿐 다른 기능을 추가할 수 없다. 즉, 유연성이 떨어진다.<br>
예를 들어보면, 과거의 유선 전화기는 전화 외에 다른 기능은 지원하지 않는다. 운영체제가 탑재되어있는 스마트폰은 애플리케이션을 설치하여, 음악을 듣거나 게임을 하는 등의 여러 기능을 할 수 있다.

### 운영체제가 하는 일
1. 프로세스 관리
2. 메모리 관리
3. 하드웨어 관리<br>
	사용자가 하드웨어에 직접 접근하지 못하도록 제어한다.
4. 파일 시스템 관리

---

## 운영체제의 역사
### (1) 1940년도: 에니악의 등장
미군지휘하에 펜실베이니아 대학교에서 설립된 컴퓨터 `에니악`이 등장한다.
최초의 목적은 미사일 탄도개선으로, 세계에서 가장 큰 스케일의 전자디지털 계산기였다.

<img src="../assets/OS-ENIAC.jpg">

스위치와 배선을 연결하여 프로그래밍을 하였다. 따라서 프로그램이 바뀌면 스위치와 배선을 다시 연결해야된다는 불편함이 있었다. 
또한 입출력 속도가 굉장히 느리고, 입출력 도중에는 계산이 불가능했다. 무게는 30톤으로 과열로 터지는 경우에는 교체도 필요했다.
이 당시에는 하드웨어가 굉장히 비쌌기 때문에, 에니악 설계자들은 "어떻게 하면 CPU를 최대한 많이 사용할 수 있을까?"를 계속해서 고민헀다.

### (2) 1950년도 초반: 직접 회로(IC)의 개발
진공관과 전선으로 만들어진 논리 회로를 아주 작은 크기로 만든 직접 회로(IC)가 개발되었다. 
CPU와 메모리는 존재하지만, 키보드와 모니터는 없었다. 
펀치카드를 이용해서 카드에 구멍을 뚫는 방식으로 프로그래밍하였고, 컴퓨터가 이 카드를 읽어 계산하고 결과는 라인 프린터로 출력되었다.
이전 에니악의 스위치와 배선을 이용한 프로그래밍 방식보다 훨씬 편해졌다. 

### (3) 1950년도 중후반: 싱글스트림 배치시스템
프로그램을 순서대로 하나씩 실행시키는 `싱글스트림 배치시스템`(Single-stream Batch Processing System, 일괄처리)을 도입한다.

이후에도 CPU의 사용성을 높이기 위한 고민은 계속되었다. 특히 입출력 작업 중 CPU를 사용하지 못한다는 문제를 해결하기 위해 입출력을 담당하는 `I/O 디바이스 컨트롤러`를 만들어 CPU로부터 입출력의 역할을 분리하였다. 
I/O 디바이스 컨트롤러는 입출력 작업이 끝나면 CPU에게 인터럽트 신호를 주고, 신호를 받은 CPU는 이를 다시 처리한다. 

CPU와 입출력을 분리했지만, CPU는 입출력 작업이 완료되어야만 계산이 가능하기 때문에 CPU의 낭비가 여전히 발생한다. (싱글스트림 배치시스템의 한계)

### (4) 1960년대: 시분할 시스템
싱글스트림 배치시스템의 한계를 해결하기 위해, 메모리에 여러 프로그램을 올려놓고 매우 빠르게 번갈아 가면서 프로그램을 실행시키는 `시분할 시스템`을 도입한다. 매우 빠르게 변경되기 때문에 사용자 입장에서는 모든 프로그램이 동시에 실행되는 것처럼 보인다.
특정 프로그램이 입출력 작업 시, CPU는 다른 프로그램의 계산 작업을 처리하면 되기 때문에 CPU 사용률을 증가시킬 수 있다. (싱글스트림 배치시스템의 한계 극복)

프로그램을 동시에 여러 개 실행할 수 있게 되었기 때문에, 여러 사용자들이 터미널 단말기를 통해 하나의 컴퓨터에 접근해서 사용할 수 있다. (그 당시에는 컴퓨터는 비싸고, 터미널은 상대적으로 저렴했다.)
사용자들은 개인용 컴퓨터를 쓰는 것 같은 효과를 얻을 수 있었기 때문에 컴퓨터에 개인정보를 저장하기 시작했고, 이때 `파일 시스템`이 등장했다.

위에서 설명한 **멀티 프로그래밍**(프로그램을 동시에 여러 개 실행) + **다중 사용자**(여러 사용자 지원) + **파일 시스템**을 구현한 `UNIX` 운영체제가 등장한다. 

또한 다른 의미로 1960년도는 멘붕의 시대였는데, 여러 프로그램을 동시에 실행시키면서 문제가 발생한다.<br>
첫번째는 메모리에 여러 프로그램이 올라오면서 메모리를 침범하는 이슈이다.<br>
두번째는 프로그램의 시작 메모리 위치를 알 수 없다는 것이다. 따라서 하드웨어적으로 `베이스 레지스터`를 추가하여 프로그램의 시작 주소를 저장했고, 모든 프로그램이 0번지에서 시작한다고 가정하여 문제를 해결하였다.

### (5) 1970년대: 개인용 컴퓨터의 시대 시작
이전보다 컴퓨터의 가격이 저렴해져서 개인용 컴퓨터를 사용할 수 있게 되었다. 애플의 매킨토시, 마이크로소프트의 MS-DOS가 많이 사용되었고, 특히 매킨토시는 GUI를 도입하여 굉장한 인기를 얻었다.

운영체제의 역사를 돌아보면, 
비싼 CPU의 사용률을 최대로 끌어올리기 위해 고민하고, 
오퍼레이터와 프로그래머 사이에서 낭비되는 시간을 줄이려고 고민하였다. 
즉, CPU 사용률과 비용절감을 위한 노력으로 오늘날의 운영체제가 탄생하였다. 

---

## 운영체제의 구조

<img src="../assets/OS-structure.png">

`커널`은 운영체제의 핵심으로 프로세스, 메모리, 저장장치를 관리하는 핵심적인 기능을 담당한다. 
사용자는 운영체제의 커널에 직접 접근할 수 없으며, 인터페이스를 통해 접근해야 한다. 
이때의 인터페이스는 `GUI`(Graphical User Interface)와 `CLI`(Command-Line Interface)가 있다.<br>
'현재 경로 변경하기'를 예로 들면, 
GUI의 경우, Finder의 폴더를 클릭하여 원하는 경로에 도달할 수 있다. CLI는 `cd` 명령어를 이용하여 똑같은 결과를 얻을 수 있다.<br>
CLI의 예로는 UNIX/Linux의 Shell, Docker CLI 등이 있고, GUI의 예로는 macOS Finder, Windows 탐색기, 웹 브라우저 등이 있다. 

`시스템 콜`은 커널이 사용자나 애플리케이션으로부터 자신을 보호하기 위해 제공하는 인터페이스로, 직접적인 자원 접근을 차단하고 운영체제를 통해서만 하드웨어를 제어할 수 있도록 한다. 예를 들어, `write()` 시스템 콜을 사용하면 애플리케이션이 직접 하드디스크에 데이터를 쓰는 것이 아니라, 운영체제가 이를 대신 처리하여 자원을 안전하게 관리한다.

하드웨어와 커널의 인터페이스로는 `드라이버`를 사용한다.
커널이 모든 하드웨어에 대한 드라이버를 가지고 있을 수 없으므로, 일반적으로 하드웨어를 만든 제조사에서 드라이버를 만들어 제공한다. 키보드나 마우스 같은 간단한 장치들은 커널에 포함되어 있지만, 그래픽카드나 타블렛 같은 복잡한 장치들은 디바이스 드라이버를 설치하여 사용해야 한다. 

---

## 컴퓨터 하드웨어와 구조
### 폰 노이만 구조
존 폰 노이만이 제시한 컴퓨터 아키텍쳐로, **프로그램 내장 방식**이라고도 부른다.

앞서 말한 에니악의 스위치와 배선 작업은 연산을 변경하려면 배선을 다시 연겨래향하는 번거로움이 있었다. 이를 해결하기 위해 1945년 폰 노이만이 "EDVAC의 보고서 초안"에서 새로운 아키텍쳐를 제안했다.

폰 노이만 구조는
최초의 `프로그램 내장 방식`으로
메모리에 올라간 프로그램이 명령어를 따라 처리되며, 소프트웨어만 바꿔도 다른 프로그램을 실행할 수 있다.

<img src="../assets/OS-Von-Neumann-architecture.png">

컴퓨터 하드웨어의 핵심은 `메인보드`로, 여러 다른 하드웨어 장치를 연결하는 역할을 한다. 장치 간에 데이터를 전송하는 것은 메인보드의 버스가 담당한다.

> 버스란, 장치 간 데이터 전송을 담당하는 공용 연결 통로이다.
>

#### CPU 구조
CPU(Central Processing Unit, 중앙처리장치)

<img src="../assets/OS-CPU-architecture.png">

1. 제어 장치(Control Unit, CU)
	<br>명령을 해석하고, 명령의 실행을 위한 제어 신호를 발생한다.
1. 산술논리 연산장치(Arithmetic/Logic Unit, ALU)
	<br>CU의 신호에 따라서 실질적인 산술/논리 연산이 일어난다.
1. 레지스터
	<br>CPU 내부에서 연산을 수행하기 위해 데이터를 임시 저장하는 고속 메모리이다.

#### 메모리 종류
- RAM(Random Access Memory, 주 기억장치)
  - 데이터의 저장 위치와 관계없이 동일한 속도로 접근 가능하다. 
  - 컴퓨터 전원이 꺼지면 데이터가 사라지는 휘발성 메모리로, 프로그램 실행을 위한 메인 메모리로 사용된다.
- ROM(Read Only Memory)
	- 전원이 꺼져도 데이터를 유지하는 비휘발성 메모리이다.
	- 일반적으로 읽기 전용이지만 일부 ROM은 수정이 가능하다. 
    - 주로 컴퓨터의 부팅 과정에서 필요한 바이오스(BIOS)나 펌웨어를 저장하는 데 사용된다.

> 정리하면, 폰 노이만 구조의 핵심요소는 `CPU`, `메모리(RAM)`, `입출력 장치`이며, `주 기억장치(메모리)`를 중심으로 프로그램과 데이터를 저장하고 처리하는 방식이다.<br>
> 즉, 하드 디스크(HDD)나 SSD는 보조 기억 장치로 폰 노이만 구조에 포함되지 않는다. 폰 노이만 구조가 등장한 1945년 당시에는 현대의 HDD/SSD와 같은 보조 기억 장치가 존재하지 않았기 때문이다. 
>  하지만, RAM은 휘발성이기 때문에, 영구적인 데이터 저장을 위해 보조 기억장치가 필요하다. 따라서, 폰 노이만 구조의 기본 모델에는 포함되지 않더라도, 현대 컴퓨터에서 보조 기억 장치는  필수적으로 추가되어 프로그램과 데이터를 장기간 보존하는 데 중요한 역할을 한다.
>

> 추가 참고<br>
> [폰 노이만 구조의 개념과 동작](https://adeuran.tistory.com/20)<br>
> [메모리 RAM이란 무엇일까?](https://information-factory.tistory.com/59)
>

---

## 컴퓨터의 부팅 과정
컴퓨터의 전원을 누르면,
1. ROM에 저장된 바이오스가 실행된다.
   전원, CPU, 메모리, 키보드, 마우스, 하드디스크 등의 주요 하드웨어의 상태를 확인한다.
	- 이때 주요 장치에 이상이 있으면 오류음을 내면서 부팅을 멈춘다.
2. 이상이 없다면, 하드디스크에 있는 마스터 부트 레코드에 저장된 부트로더를 메모리로 가져와서 실행시킨다.
3. 운영체제를 메모리로 불러오고 모니터에 바탕화면이 보인다.
   - 운영체제가 여러 개 설치된 컴퓨터라면 운영체제를 선택하는 과정을 선행한다.
4. 이후 모든 응용 프로그램은 메모리에 올라와서 운영체제가 관리한다.

---

## 인터럽트(Interrupt)
`인터럽트`란 프로세스 실행 중 특정 이벤트가 발생하면 해당 상황을 처리한 후 원래 작업으로 복귀하는 과정을 말한다.

### 인터럽트의 필요성	
CPU는 입출력 작업이 들어오면, 입출력 관리자에게 입출력 명령을 내린다. 이때 CPU 입장에서는 입출력 작업이 언제 완료될 지 모르기 때문에 주기적으로 확인해주어야 한다. 이러한 방식을 **폴링(polling) 방식**이라한다. 폴링 방식은 CPU가 지속적으로 입출력 작업이 완료되었는지 확인하며 불필요하게 자원을 낭비하는 문제가 있다. 
인터럽트 방식에서는 CPU가 입출력 명령을 내린 후 다른 작업을 수행하고, 입출력 장치가 완료 신호를 보낼 때만 CPU가 응답하도록 함으로써 이 문제를 해결한다.

### 실행 과정
1. CPU가 입출력 관리자에게 입출력 명령을 내리고, CPU는 다른 작업을 수행한다. 
2. 입출력 관리자가 입출력이 완료되었을 때 CPU에게 인터럽트 신호를 보낸다.
3. CPU는 현재 작업을 멈추고 인터럽트 서비스 루틴(ISR)을 실행하여 처리한다.
4. 인터럽트 처리가 완료되면 이전 작업으로 복귀한다.

<br>

> 인터럽트 서비스 루틴(ISR, Interrupt Service Routine)이란,<br> 특정 인터럽트가 발생하면 실행되는 함수로, 인터럽트마다 고유한 ISR이 존재한다.

### 인터럽트 종류
**하드웨어 인터럽트(외부 인터럽트)**
- 출력
- 타이머 인터럽트
- 전원 이상입

**내부 인터럽트 / 소프트웨어 인터럽트**
- CPU가 실행 중인 프로그램에서 발생
- 예외(exception)
  - 유효하지 않은 메모리 접근
  - 0으로 나누는 작업
- 시스템 콜(System Call) : 사용자 프로그램이 운영체제의 기능 호출
  - `write()`, `read()` etc


> 추가 참고<br>
> [[운영체제 7편] 인터럽트가 무엇인가](https://baebalja.tistory.com/354)
>

---

# Section2. 프로세스와 스레드
## 프로그램과 프로세스
### 프로그램(Program)
- **저장장치에 저장된 명령문의 집합**으로, 실행되지 않은 `정적` 상태의 코드
- 운영체제에서 실행되지 않은 상태로 존재하는 `수동적`인 개체. 
- 애플리케이션(앱) 뿐만 아니라 운영체제, 유틸리티 프로그램도 포함된다.
- `.exe` in Windows

### 프로세스(Process)
- 실행 중인 프로그램으로, **프로그램이 메모리에 적재되어 운영체제의 관리 하에 실행되는 동적 개체**
- 프로그램과 다르게, 메모리를 사용하고, 운영체제의 CPU 스케줄링 알고리즘에 따라 CPU를 사용하며, 경우에 따라서 입출력 작업도 한다는 관점에서 `능동적`인 존재이다.

#### 프로세스 메모리 구조
<img src="../assets/OS-process-memory.png">

- 힙영역은 프로그래머가 런타임 시 할당할 수 있는 메모리 공간으로, C언어의 `malloc()` / `free()` 함수를 사용하여 메모리가 동적 할당 및 해제 된다.

<br>

### C언어 컴파일 과정
**컴파일(Compile)** 이란?<br>
사람이 이해할 수 있는 고급언어로 작성된 소스코드를 컴퓨터가 실행 가능한 형식의 기계어로 변환하는 작업이다.
<img src="../assets/OS-C-Compile.png">

1. 전처리기
- 헤더 파일 삽입 (`#include`)
- 매크로 치환 및 적용 (`#define`, `#ifdef` etc)

2. 컴파일러
- 전처리된 코드를 어셈블리어로 변환하는 과정을 거친다.

3. 어셈블러
- 어셈블리어를 기계어(바이너리 코드)로 변환한다.

4. 링커
- 여러 개의 오브젝트 파일과 프로그램 실행에 필요한 라이브러리를 연결하여 실행 가능한 바이너리(.exe, .out)를 생성한다.

---

## 멀티 프로그래밍, 멀티 태스킹, 멀티 프로세싱
메모리의 관점에서, 메모리에 적재된 프로세스의 수에 따라서 분류할 수 있다.

**유니 프로그래밍 (Uni-programming)**
- 메모리에 오직 하나의 프로세스가 올라온 것
- 문제
  - 프로세스 실행 중 I/O 작업이 완료될 때까지 대기해야 하기 때문에, CPU의 쉬는 시간이 발생하는 단점 존재
  - 하나의 프로세스 작업이 완료되어야 다른 프로세스를 실행할 수 있다.

**멀티 프로그래밍 (Multiprogramming)**
- 메모리에 여러 개의 프로세스가 올려두고 실행 대기 상태로 유지하는 것
- 한 프로세스가 I/O 작업으로 인해 대기 상태에 있을 때, 다른 프로세스에 CPU를 할당하여 전체 시스템 효율을 향상시킨다.

**멀티 태스킹(MultiTasking)** 은
하나의 CPU가 여러 작업을 빠르게 전환하며 실행하면서, 모든 프로세스를 동시에 실행시키는 것처럼 느끼게 하는 기술<br>
멀티 프로그래밍을 확장하여 CPU 스케줄링 기법을 추가하였다. 컨텍스트 스위칭을 통해 여러 작업을 동시에 실행하는 것처럼 보이게 한다.

> ⚠️ 멀티 태스킹은 멀티 프로그래밍의 한 형태이며, 멀티 프로그래밍은 더 넓은 개념이다.<br>
> 멀티 프로그래밍은 메모리에 여러 프로세스를 올려두고 CPU가 적절히 스케줄링하는 것이고, 멀티 태스킹은 그중에서 CPU 스케줄링을 통해 컨텍스트 스위칭하면서 여러 프로세스를 실행하는 기법이다.<br>
> 즉, `멀티 프로그래밍 = 메모리 관점`, `멀티 태스킹 = CPU 관점`
> 

더 나아가서 **멀티 프로세싱(Multi-processing)** 이란,<br>
여러 개의 CPU(프로세서)가 각각 독립적으로 여러 개의 프로세스를 처리하는 것이다.<br>
여러 작업을 실행시키는 것처럼 보이게 하는 멀티 프로그래밍, 멀티태스킹과 다르게 멀티 프로세싱은 `실제로 여러 개의 프로세스`가 물리적으로 동시에 실행된다.

오늘 날의 OS는 멀티 프로그래밍과 멀티 프로세싱을 지원하지만, 
과거에는 프로그램을 여러 개 올릴 크기의 메모리가 부족하여 유니 프로그래밍과 멀티 태스킹 환경이 주로 사용되었다.<br>
이때, 멀티 태스킹을 지원하는 메모리 관리 기법 중 하나인 스와핑 기법을 사용하였다. `스와핑(swapping)` 기법이란, 실행 중인 프로세스(메모리에 적재된 하나의 프로세스)를 보조 기억장치(ex. HDD)에 저장했다가, 필요할 때 다시 메모리에 불러오는 방식이다. 하지만, 스와핑은 입출력 작업이 많아 시스템 성능 저하를 초래할 수 있다. 따라서 이를 해결하기 위해 `가상 메모리(Virtual Memory)` 기법이 도입되어 프로세스의 일부만 메모리에 올리고도 실행할 수 있도록 개선되었다.

정리하면
|  | 멀티 프로그래밍 | 멀티 태스킹 | 멀티 프로세싱 |
| --- | --- | --- | --- |
| 실행 방식 | 여러 프로그램을 메모리에 올려두고 실행 대기 | CPU가 여러 작업을 빠르게 번갈아 가며 실행시킨다.
 | 여러 개의 CPU가 여러 프로세스를 동시에 실행시킨다. |
| CPU 사용 방식 | 하나의 CPU가 하나의 프로세스를 | 하나의 CPU가 컨텍스트 스위칭을 통해  | 여러 개의 CPU가 독립적으로  |
| 특징 | I/O 작업 중인 프로세스를 대기시키고 다른 프로세스를 실행 | 타임 슬라이스(Time Slice, 짧은 시간)를 사용하여 여러 작업이 동시에 실행되는 것처럼 보이게 함 | 실제로 병렬 실행 가능 |

---

## PCB(Process Control Back)
운영체제가 프로세스를 제어하기 위해 프로세스의 상태 정보를 저장하는, 운영체제 커널의 자료구조

- 프로세스 생성 시, 운영체제는 해당 프로세스의 정보를 가지고 있는 PCB를 만들고 저장한다. 
- 연결리스트의 자료구조로 저장된다.
- 프로세스 종료 시, PCB도 함께 삭제된다.

### PCB 구조
<img src="../assets/OS-Process-Control-Block.webp" style="width: 300px; height: 500px;">

- 포인터
  - 부모와 자식 프로세스에 대한 포인터
  - 할당된 자원에 대한 포인터
  - 프로세스의 상태 전환 시 저장하는 포인터
- 프로세스 상태
  - 현재 프로세스의 다섯가지 상태(생성, 준비, 실행, 대기, 완료) 중 하나를 저장한다.
- 프로세스 ID
  - 프로세스를 식별하기 위한 숫자
- 프로그램 카운터(Program Counter, PC)
  - 다음에 실행될 명령어의 주소를 포함한다.
  > 왜 필요한가?<br>
	시분할 처리 시, 다른 프로세스에 CPU를 뺏기고 다시 실행될 때, 기존에 실행하던 명령어의 위치를 알아야 작업을 이어갈 수 있다.
- 레지스터 정보
  - 프로세스가 실행될 때 사용했던 레지스터 값들이 저장된다.
  - PC와 같은 목적으로, CPU를 뺏기고 다시 시작할 때 이전에 사용하던 값을 복구하기 위한 용도이다.
- 메모리 관련 정보
  - 프로세스가 메모리에 있는 위치 정보
  - 메모리 침범을 막기 위한 경계레지스터 값
- CPU 스케줄링 정보
  - CPU 스케줄링에 필요한 우선순위
  - 최종 실행 시간
  - CPU 점유 시간
  
> 추가 참고
> [Process Table and Process Control Block (PCB)](https://www.geeksforgeeks.org/process-table-and-process-control-block-pcb/)

---

## 프로세스 상태
<img src="../assets/OS-process-state.png">

- `생성(New)`
	- 프로세스가 메모리에 적재되기 전에 초기화 작업을 하는 단계
	- 프로세스 제어 블록(PCB)을 생성
	- 메모리 할당 요청
	- 승인되면 준비 상태로 이동한다.
- `준비(Ready)`
  - CPU를 할당받기 위해 대기 중인 상태
  - CPU 스케줄러에 의해 CPU가 할당된다.
  - 대부분의 프로세스는 준비 상태에 있다.
- `실행(Running)`
  - 준비 상태에 있는 프로세스가 CPU 스케줄러에 의해 CPU를 할당받아 실행되는 상태
  - `실행상태에 있는 프로세스의 수` = `CPU의 개수`<br>
	즉, CPU가 한 개인 컴퓨터에서 실행 상태에 있는 프로세스는 최대 한 개이다.
  - 실행 상태에 있는 프로세스도 CPU를 무한정 쓸 수 있는 것은 아니다. CPU 스케줄러는 부여된 시간이 초과되면 프로세스에 할당된 CPU를 빼앗는다. CPU를 빼앗긴 프로세스는 다시 준비 상태가 된다. 
- `대기(Waiting)`
  - 프로세스가 입출력 요청이나 다른 자원 대기를 요청하는 상태
  - CPU는 굉장히 빠른 장치임에 비해 입출력 작업은 상당히 느린 작업이다.<br>
	따라서 입출력 작업이 완료될 때까지 기다리는 프로세스에 CPU를 할당하는 것은 굉장히 비효율적이다.
  - 입출력 작업이 완료되면, 대기 상태의 프로세스는 준비 상태로 돌아가며, CPU를 할당받을 수 있다.
- `완료(Terminated)`
	- 프로세스가 종료된 상태
	- 프로세스의 자원(메모리, PCB 등)은 모두 반환되며, 메모리에서 제거되고, PCB도 삭제된다.
